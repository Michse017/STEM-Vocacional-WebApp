import pyodbc
import time
import getpass
from database.config import get_connection_string, get_database_url

def test_sql_authentication():
    """Test completo con SQL Authentication - Driver 17"""
    try:
        print("üöÄ TEST SQL AUTHENTICATION - DRIVER 17")
        print("=" * 60)
        
        # Solicitar contrase√±a una sola vez
        password = getpass.getpass("üîê Contrase√±a para michsega17@gmail.com@stemdb: ")
        
        # Connection string con Driver 17 (consistente con config.py)
        conn_str = (
            "Driver={ODBC Driver 17 for SQL Server};"
            "Server=tcp:stemdb.database.windows.net,1433;"
            "Database=StemDB;"
            "Uid=michsega17@gmail.com@stemdb;"
            f"Pwd={password};"
            "Encrypt=yes;"
            "TrustServerCertificate=no;"
            "Connection Timeout=60;"
        )
        
        print("‚è≥ Conectando con SQL Authentication (Driver 17)...")
        start_time = time.time()
        
        conn = pyodbc.connect(conn_str)
        elapsed = time.time() - start_time
        
        print(f"‚úÖ ¬°CONEXI√ìN EXITOSA! Tiempo: {elapsed:.1f}s")
        
        cursor = conn.cursor()
        
        # Informaci√≥n b√°sica
        cursor.execute("SELECT DB_NAME() as database_name, SUSER_NAME() as user_name")
        result = cursor.fetchone()
        
        print(f"üìä Base de datos: {result.database_name}")
        print(f"üë§ Usuario conectado: {result.user_name}")
        print(f"üñ•Ô∏è Versi√≥n: Azure SQL Database")
        
        # Verificar tablas
        cursor.execute("""
            SELECT TABLE_NAME 
            FROM INFORMATION_SCHEMA.TABLES 
            WHERE TABLE_TYPE = 'BASE TABLE'
            ORDER BY TABLE_NAME
        """)
        tables = cursor.fetchall()
        
        print(f"\nüóÇÔ∏è Tablas encontradas ({len(tables)}):")
        expected_tables = ['resp_autoeficacia', 'resp_cognitiva', 'resp_educativa_familiar', 'resp_socioeconomica', 'usuarios']
        
        for table in tables:
            table_name = table.TABLE_NAME
            status = "‚úÖ" if table_name in expected_tables else "‚ö†Ô∏è"
            print(f"  {status} {table_name}")
        
        if len(tables) == 5:
            print("\nüéâ ¬°Todas las 5 tablas est√°n correctas!")
        
        # Analizar estructura del campo codigo_estudiante ANTES de insertar
        cursor.execute("""
            SELECT COLUMN_NAME, DATA_TYPE, CHARACTER_MAXIMUM_LENGTH 
            FROM INFORMATION_SCHEMA.COLUMNS 
            WHERE TABLE_NAME = 'usuarios' AND COLUMN_NAME = 'codigo_estudiante'
        """)
        col_info = cursor.fetchone()
        max_length = col_info.CHARACTER_MAXIMUM_LENGTH if col_info else 50
        print(f"\nüìè Campo codigo_estudiante: m√°ximo {max_length} caracteres")
        
        # Test de operaciones CRUD B√ÅSICAS
        print(f"\nüîß PROBANDO OPERACIONES CRUD:")
        
        # 1. READ: Contar registros
        cursor.execute("SELECT COUNT(*) FROM usuarios")
        user_count = cursor.fetchone()[0]
        print(f"üìä Registros en usuarios: {user_count}")
        
        # 2. CREATE: Insertar registro de prueba CON TAMA√ëO CORRECTO
        test_code = f"T{int(time.time() % 1000000)}"  # C√≥digo corto: T123456
        if len(test_code) > max_length:
            test_code = test_code[:max_length]
        
        cursor.execute("INSERT INTO usuarios (codigo_estudiante) VALUES (?)", test_code)
        conn.commit()
        print(f"‚ûï Registro insertado: {test_code} ({len(test_code)} caracteres)")
        
        # 3. READ: Verificar inserci√≥n
        cursor.execute("SELECT COUNT(*) FROM usuarios WHERE codigo_estudiante = ?", test_code)
        count = cursor.fetchone()[0]
        print(f"üîç Verificaci√≥n inserci√≥n: {count} registro(s)")
        
        # 4. UPDATE: Test b√°sico de actualizaci√≥n (si hay m√°s columnas)
        cursor.execute("""
            SELECT COLUMN_NAME 
            FROM INFORMATION_SCHEMA.COLUMNS 
            WHERE TABLE_NAME = 'usuarios'
            ORDER BY ORDINAL_POSITION
        """)
        columns = [row.COLUMN_NAME for row in cursor.fetchall()]
        print(f"üìã Columnas en usuarios: {', '.join(columns)}")
        
        # 5. DELETE: Limpiar registro de prueba
        cursor.execute("DELETE FROM usuarios WHERE codigo_estudiante = ?", test_code)
        conn.commit()
        print(f"üóëÔ∏è Registro de prueba eliminado")
        
        # Conteo de registros en todas las tablas
        print(f"\nüìä ESTADO ACTUAL DE TODAS LAS TABLAS:")
        for table_name in expected_tables:
            try:
                cursor.execute(f"SELECT COUNT(*) FROM {table_name}")
                count = cursor.fetchone()[0]
                print(f"  üìä {table_name}: {count} registros")
            except Exception as e:
                print(f"  ‚ö†Ô∏è Error en {table_name}: {e}")
        
        # Estructura completa de tablas
        print(f"\nüèóÔ∏è ESTRUCTURA DE TABLAS:")
        for table_name in expected_tables:
            try:
                cursor.execute(f"""
                    SELECT COUNT(*) as column_count
                    FROM INFORMATION_SCHEMA.COLUMNS 
                    WHERE TABLE_NAME = '{table_name}'
                """)
                col_count = cursor.fetchone()[0]
                print(f"  üìã {table_name}: {col_count} columnas")
            except Exception as e:
                print(f"  ‚ö†Ô∏è Error estructura {table_name}: {e}")
        
        conn.close()
        return True, password, max_length
        
    except Exception as e:
        print(f"‚ùå Error: {e}")
        
        if "Login failed" in str(e):
            print("\nüîê PROBLEMA DE AUTENTICACI√ìN:")
            print("  ‚ùå Usuario o contrase√±a incorrectos")
        elif "truncated" in str(e).lower():
            print("\nÔøΩ PROBLEMA DE TAMA√ëO:")
            print("  ‚ùå Campo codigo_estudiante muy peque√±o")
            print("  üí° Usar c√≥digos m√°s cortos")
        elif "timeout" in str(e).lower():
            print("\n‚è∞ PROBLEMA DE TIMEOUT:")
            print("  ‚ùå Conexi√≥n muy lenta o BD pausada")
        
        return False, None, None

def test_sqlalchemy_integration(password, max_length=10):
    """Test SQLAlchemy con SQL Authentication - SOLO BD"""
    try:
        print("\nüîß TEST SQLALCHEMY - SOLO CONEXI√ìN Y QUERIES B√ÅSICAS")
        print("=" * 50)
        
        from sqlalchemy import create_engine, text
        
        # URL con Driver 17
        database_url = (
            f"mssql+pyodbc://michsega17%40gmail.com%40stemdb:{password}@"
            f"stemdb.database.windows.net:1433/StemDB?"
            f"driver=ODBC+Driver+17+for+SQL+Server&"
            f"encrypt=yes&"
            f"TrustServerCertificate=no&"
            f"timeout=60"
        )
        
        print("‚è≥ Creando engine SQLAlchemy...")
        engine = create_engine(database_url)
        
        with engine.connect() as conn:
            # Query b√°sica
            result = conn.execute(text("""
                SELECT 
                    DB_NAME() as database_name,
                    COUNT(*) as table_count
                FROM INFORMATION_SCHEMA.TABLES 
                WHERE TABLE_TYPE = 'BASE TABLE'
            """))
            row = result.fetchone()
            
            print(f"‚úÖ SQLAlchemy engine funcionando!")
            print(f"üìä Base de datos: {row.database_name}")
            print(f"üóÇÔ∏è Tablas: {row.table_count}")
            
            # Test de lectura simple
            result2 = conn.execute(text("SELECT COUNT(*) as total FROM usuarios"))
            users_count = result2.fetchone()
            print(f"üë• Usuarios actuales: {users_count.total}")
            
            # Test de inserci√≥n CORTA con SQLAlchemy
            short_code = f"S{int(time.time() % 100000)}"  # Muy corto: S12345
            if len(short_code) > max_length:
                short_code = short_code[:max_length]
                
            print(f"üìè Probando inserci√≥n: {short_code} ({len(short_code)} chars)")
            
            conn.execute(text("INSERT INTO usuarios (codigo_estudiante) VALUES (:code)"), {"code": short_code})
            conn.commit()
            print(f"‚ûï Inserci√≥n SQLAlchemy exitosa")
            
            # Verificar inserci√≥n
            result3 = conn.execute(text("SELECT COUNT(*) as total FROM usuarios WHERE codigo_estudiante = :code"), {"code": short_code})
            verify_count = result3.fetchone()
            print(f"üîç Verificaci√≥n: {verify_count.total} registro insertado")
            
            # Limpiar test
            conn.execute(text("DELETE FROM usuarios WHERE codigo_estudiante = :code"), {"code": short_code})
            conn.commit()
            print(f"üßπ Test data limpiada")
            
        return True
        
    except Exception as e:
        print(f"‚ùå Error SQLAlchemy: {e}")
        
        if "truncated" in str(e).lower():
            print(f"üí° Campo codigo_estudiante muy peque√±o (max: {max_length} chars)")
            print("üí° Necesario usar c√≥digos m√°s cortos")
        
        return False

def test_config_functions():
    """Test b√°sico de funciones del config.py"""
    try:
        print("\nüîó TEST FUNCIONES DE CONFIG.PY")
        print("=" * 40)
        
        # Test funciones principales
        conn_str = get_connection_string()
        db_url = get_database_url()
        
        print("‚úÖ get_connection_string() funcionando")
        print("‚úÖ get_database_url() funcionando")
        
        # Test conexi√≥n directa usando config
        import pyodbc
        conn = pyodbc.connect(conn_str)
        cursor = conn.cursor()
        cursor.execute("SELECT DB_NAME() as db")
        result = cursor.fetchone()
        conn.close()
        
        print(f"‚úÖ Conexi√≥n usando config exitosa!")
        print(f"üìä Base de datos conectada: {result.db}")
        
        return True
        
    except Exception as e:
        print(f"‚ùå Error en config functions: {e}")
        return False

if __name__ == "__main__":
    print("üß™ TEST COMPLETO - ENFOQUE EN BASE DE DATOS")
    print("=" * 70)
    
    # Test 1: SQL Authentication + operaciones CRUD b√°sicas
    success, password, max_length = test_sql_authentication()
    
    # Test 2: SQLAlchemy b√°sico (si pyodbc funciona)
    sqlalchemy_ok = False
    if success and password:
        sqlalchemy_ok = test_sqlalchemy_integration(password, max_length or 10)
    
    # Test 3: Funciones del config (b√°sico)
    config_ok = False
    if success:
        config_ok = test_config_functions()
    
    # Resumen final
    print("\n" + "=" * 70)
    print("üéØ RESUMEN - TESTS DE BASE DE DATOS")
    print("=" * 70)
    print(f"  üîå pyodbc + Driver 17: {'‚úÖ OK' if success else '‚ùå FALLO'}")
    print(f"  üîß SQLAlchemy b√°sico: {'‚úÖ OK' if sqlalchemy_ok else '‚ùå NO PROBADO' if not success else '‚ùå FALLO'}")
    print(f"  üîó Config functions: {'‚úÖ OK' if config_ok else '‚ùå NO PROBADO' if not success else '‚ùå FALLO'}")
    
    if success:
        print(f"\n‚úÖ CAMPO codigo_estudiante: m√°x {max_length or 10} caracteres")
        print("‚úÖ Operaciones CRUD b√°sicas funcionando")
        print("‚úÖ Conexi√≥n Azure SQL estable")
    
    if success and sqlalchemy_ok and config_ok:
        print("\nüéâ ¬°BASE DE DATOS 100% FUNCIONAL!")
        print("‚úÖ pyodbc funcionando perfectamente")
        print("‚úÖ SQLAlchemy compatible")
        print("‚úÖ Config.py optimizado")
        print("\nüöÄ LISTO PARA:")
        print("   1. python run_tests.py  ‚Üê Tests principales")
        print("   2. Desarrollo de l√≥gica de aplicaci√≥n")
        print("   3. Formularios conectados a BD")
    elif success:
        print("\nüéØ Base de datos principal funciona")
        print("üí° SQLAlchemy puede necesitar ajustes menores")
        print("üí° Continuar con: python run_tests.py")
    else:
        print("\n‚ö†Ô∏è PRIORIDAD: Arreglar conexi√≥n b√°sica de BD")
        print("1. Verificar credenciales Azure")
        print("2. Verificar que BD no est√© pausada")
        print("3. Verificar Driver 17 instalado")